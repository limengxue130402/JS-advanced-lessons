<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    //基础的闭包的结构
    function foo(x){
        var tmp = 10;
        return function(y){
            console.log(x + y, ++ tmp);
        }
    }
    var fee = foo(10);
    fee(10);

    //闭包的常见形式
    //以函数对象形式返回
    function foo(x){
        var tmp = 3;
        return function(y){
            x.count = x.count ? x.count + 1: 1;
            console.log(x + y + tmp, c.count);
        }
    }
    var age = new Number(2);
    var bar = foo(age);
    bar(10);
    bar(10);
    bar(10);



    //作为对象的方法返回
    function counter(){
        var n = 0;
        return {
            count: function(){return ++n;},
            reset: function(){n = 0; return n;}
        }
    }
    var c = counter(), d = counter();
    console.log(c.count());
    console.log(d.count());
    console.log(c.reset());
    console.log(c.count());
    console.log(d.count());




    /*对象 instanceof 构造函数
    1：判断对象能否使用该构造函数实例化得到
    2：判断对象的原型链上能够找到该构造函数的原型
    对象.__proto__.__proto__（长度不确定）==构造函数.prototype
    结果为true或false
    */
    console.log(Object instanceof Function);



    function Person(username, age){
        this.username = username;
        this.age = age;
    }
    var p =new Person("zhangsan",20);
    console.log(p.__proto__ == Person.prototype);


    var a ={
        _x: 1,
        get x(){
            return this._x;
        },
        set x(val){
            this._x = val;
        }
    }
    o.x = 10;
    console.log(o.x);
</script>
</html>